// Define constants for encryption parameters
const ITERATIONS = 100000;
const SALT_LENGTH = 16;
const IV_LENGTH = 12;

/**
 * Derives a cryptographic key from a password string using PBKDF2.
 */
async function getPasswordKey(password: string): Promise<CryptoKey> {
  const enc = new TextEncoder();
  return await crypto.subtle.importKey(
    "raw",
    enc.encode(password),
    { name: "PBKDF2" },
    false,
    ["deriveBits", "deriveKey"],
  );
}

/**
 * Derives an AES-GCM key using the password key and a random salt.
 */
async function deriveKey(
  passwordKey: CryptoKey,
  salt: Uint8Array,
): Promise<CryptoKey> {
  return await crypto.subtle.deriveKey(
    {
      name: "PBKDF2",
      salt: salt,
      iterations: ITERATIONS,
      hash: "SHA-256",
    },
    passwordKey,
    { name: "AES-GCM", length: 256 },
    true,
    ["encrypt", "decrypt"],
  );
}

/**
 * Encrypts any serializable data using a password.
 * Returns a Base64 string containing the salt, IV, and ciphertext.
 */
export async function encryptData(
  data: any,
  password: string,
): Promise<string> {
  const enc = new TextEncoder();
  const encodedData = enc.encode(JSON.stringify(data));

  const salt = crypto.getRandomValues(new Uint8Array(SALT_LENGTH));
  const iv = crypto.getRandomValues(new Uint8Array(IV_LENGTH));

  const passwordKey = await getPasswordKey(password);
  const aesKey = await deriveKey(passwordKey, salt);

  const encryptedContent = await crypto.subtle.encrypt(
    { name: "AES-GCM", iv: iv },
    aesKey,
    encodedData,
  );

  const encryptedBytes = new Uint8Array(encryptedContent);
  const combined = new Uint8Array(
    salt.length + iv.length + encryptedBytes.length,
  );
  combined.set(salt, 0);
  combined.set(iv, salt.length);
  combined.set(encryptedBytes, salt.length + iv.length);

  // Convert Uint8Array to Base64
  let binary = "";
  const chunkSize = 0x8000;
  for (let i = 0; i < combined.length; i += chunkSize) {
    binary += String.fromCharCode(...combined.subarray(i, i + chunkSize));
  }
  return btoa(binary);
}

/**
 * Decrypts a Base64 string generated by encryptData using the correct password.
 * Returns the parsed JSON data.
 */
export async function decryptData(
  encryptedBase64: string,
  password: string,
): Promise<any> {
  try {
    const binary = atob(encryptedBase64);
    const combined = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
      combined[i] = binary.charCodeAt(i);
    }

    const salt = combined.subarray(0, SALT_LENGTH);
    const iv = combined.subarray(SALT_LENGTH, SALT_LENGTH + IV_LENGTH);
    const encryptedBytes = combined.subarray(SALT_LENGTH + IV_LENGTH);

    const passwordKey = await getPasswordKey(password);
    const aesKey = await deriveKey(passwordKey, salt);

    const decryptedContent = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv: iv },
      aesKey,
      encryptedBytes,
    );

    const dec = new TextDecoder();
    const jsonStr = dec.decode(decryptedContent);
    return JSON.parse(jsonStr);
  } catch (e) {
    throw new Error("Decryption failed. Incorrect password or corrupted data.");
  }
}
